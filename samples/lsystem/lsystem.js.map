{"version":3,"sources":["../samples/browser/lsystem/lsystem.fsx"],"names":[],"mappings":"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","file":"lsystem.js","sourceRoot":"/Users/alfonsogarciacaronunez/Documents/Github/Fable/temp","sourcesContent":["(**\n - title: L-system generator\n - tagline: Interactive fractal generator\n - app-style: width:600px; padding:20px 0px 10px 0px; margin:0px auto 0px auto;\n - intro: This demo is based on [L-system workshop](https://github.com/Andrea/Lsystem) by Andrea Magnorsky\n   and Ross McKinlay. Rather than working on the tasks they gave us, I compiled it with Fable, so that you\n   can play with it in a browser!\n\n   The demo lets you enter a simple [L-system](https://en.wikipedia.org/wiki/L-system) with a single\n   entry point and a number of rewriting rules written using `->`. You can use letters to draw a line\n   forward, `-` and `+` to turn (left and right) and `!` to randomly change color. It also supports\n   brackets, e.g. `[[-X]+X]`, for undoing state changes.\n*)\n(*** hide ***)\n#r \"node_modules/fable-core/Fable.Core.dll\"\n#load \"html.fs\"\nopen Fable.Import.Browser\nopen Fable.Html\n\n(*** define:arrayhacks ***)\n[<Fable.Core.Emit(\"$0.push($1)\")>]\nlet push (sb:'a[]) (v:'a) = failwith \"js\"\n[<Fable.Core.Emit(\"$0.join($1)\")>]\nlet join (sb:'a[]) (sep:string) = failwith \"js\"\n\ntype ``[]``<'a> with\n  member x.push(v) = push x v\n  member x.join(s) = join x s\n\n(**\nRendering fractals with SVG\n---------------------------\n\nThe demo uses SVG to render fractals. Once the fractal is generated, it is turned into a sequence\nof lines that are then rendered. Each line has a starting and ending point together with a\ncolor. We represent this using a simple F# domain model:\n*)\ntype Point = { x : float; y : float }\ntype Color = { r:int; g:int; b:int; }\ntype LineSegment = {startPoint : Point; endPoint : Point; color : Color }\n(**\nWhen rendering lines, we generate `<svg>` tag containing a number of\n`<line>` elements. This is done using a simple helper library (which you can find\n[in the Fable repository](https://github.com/fsprojects/Fable/blob/lsystems/samples/browser/lsystem/html.fs)).\nThe library uses the dynamic operator `?` to generate SVG elements. For example, you can write:\n\n    s?svg [ \"width\" => 600 ] [\n      s?line [ \"x1\" => 100; \"y1\" => 100; \"x2\" => 200; \"y2\" => 200 ]\n    ]\n\nThe result of `s?svg` is a function that takes a list of attributes and a list of nested elements.\nWriting a rendering function is now easy - we just generate root SVG element with a line for each\n`LineSegment`. The only slightly complex aspect is that we re-scale the image to fit into the\n600x600 box automatically:\n*)\nlet render lineWidth lines =\n  // Calculate minimal and maximal X/Y values for scaling\n  let xs = lines |> Seq.collect (fun l -> [l.startPoint.x; l.endPoint.x])\n  let ys = lines |> Seq.collect (fun l -> [l.startPoint.y; l.endPoint.y])\n  let minx, maxx = Seq.min xs, Seq.max xs\n  let miny, maxy = Seq.min ys, Seq.max ys\n  let convx x = (x - minx) / (maxx - minx) * 600.0\n  let convy y = (y - miny) / (maxy - miny) * 600.0\n\n  // Generate root SVG tag with line tag for each line sgement\n  s?svg [\"width\" => 600; \"height\" => 600] [\n    for line in lines ->\n      s?line\n        [ \"x1\" => convx line.startPoint.x; \"y1\" => convy line.startPoint.y\n          \"x2\" => convx line.endPoint.x; \"y2\" => convy line.endPoint.y\n          \"style\" =>\n            sprintf \"stroke:rgb(%i,%i,%i);stroke-width:%i\"\n              line.color.r line.color.g line.color.b lineWidth ] []\n  ]\n(**\nFrom turtle graphics to line sgemnets\n-------------------------------------\n\nTo make the evaluation of L-systems easier, we first turn L-system into commands of a simple\nturtle graphics engine:\n*)\ntype LogoCommand =\n  | DrawForward of float\n  | Turn of float\n  | Push\n  | Pop\n  | RandomColor\n\ntype LTurtle =\n  { angle : float\n    x : float\n    y : float\n    c : Color}\n(**\nThe `DrawForward` and `Turn` commands move the turtle forward or rotate it. The `Push` and `Pop`\ncommands are used to implement the brackets - `Push` stores the current state of the turtle and\n`Pop` restores the previous state. Finally, `RandomColor` corresponds to `!` and changes the color\nto a new, randomly generated one:\n*)\nlet chaos = System.Random()\nlet randomColor() =\n  { r = (chaos.Next 256);\n    g = (chaos.Next 256);\n    b = (chaos.Next 256) }\n(**\nThe interpreter of the turtle graphics needs to keep track of the current position and direction\nof the turtle. It iterates over the commands one by one and either updates the current state or\ngenerates a line segment:\n*)\n/// interprets a logo program and produces a line segment list to render\nlet processTurtle turtle program =\n  let rec phono stack output turtle = function\n    | [] -> output\n    | RandomColor :: t ->\n        // Change current color of the turtle\n        phono stack output { turtle with c = randomColor() } t\n    | Push :: t ->\n        // Store current state on the stack\n        phono (turtle::stack) output turtle t\n    | Pop :: t when List.isEmpty stack ->\n        // Silently ignore errors when stack is empty\n        phono stack output turtle t\n    | Pop :: t ->\n        // Pop the most recent turtle state from the stack\n        phono (List.tail stack) output (List.head stack) t\n\n    | DrawForward d :: t ->\n        // Move forward by `d` in the current direction\n        let rads = turtle.angle * (System.Math.PI / 180.0)\n        let x = turtle.x + d * cos rads\n        let y = turtle.y + d * sin rads\n        let newTurtle = {turtle with x = x; y= y }\n        let seg =\n          { startPoint = {x = turtle.x; y = turtle.y}\n            endPoint = {x = x; y = y}; color = turtle.c }\n        phono stack (seg::output) newTurtle t\n\n    | Turn delta :: t ->\n        // Rotate by the specified angle\n        let d = turtle.angle + delta\n        let d =\n          if delta > 0.0 && d > 360.0 then d - 360.0\n          elif delta < 0.0 && d < 0.0 then 360.0 + d\n          else d\n        phono stack output {turtle with angle = d} t\n\n  List.rev (phono [] [] turtle program)\n(**\nProcessing and rendering L-systems\n----------------------------------\n\nAn L-system is represented by an initial state (called an axiom) and a function that returns the\nproduction (new L-system string on the right of `->`) for a given character:\n*)\ntype LSystem =\n  { Axiom : string\n    Productions : char -> string }\n(**\nWhen processing an L-system, we start with an initial string and repeatedly (for a given number\nof iterations) replace all the characters in the string with a new string produced by the\n`Productions` function. To do this efficiently, we're going to use mutable JavaScript arrays.\nIn JavaScript, you can call `ar.push(x)` on an array `ar` to add an element `x` to the end of the\narray. We can use F# extensions and `Emit` attribtue to enable calling this member on an F# array\n(this is slightly ugly, but it does the trick!):\n*)\n(*** include:arrayhacks ***)\n(**\nNow we have everything we need to implement a function that processes the L-system:\n*)\nlet processLsystem max lsystem =\n  let rec gen (current:string) iteration =\n    if iteration = max then current else\n    // Iterate over characters, appending the result of\n    // production to the mutable array `sb` of strings\n    let sb = [||]\n    for x in current.ToCharArray() do\n      sb.push(lsystem.Productions x)\n    gen (sb.join(\"\")) (iteration+1)\n\n  // Start with the initial axiom\n  gen lsystem.Axiom 0\n(**\nThe `processLsystem` function turns an L-system specification into a single large string that\nrepresents the actions that we want to do. This pretty much directly corresponds to the turtle\ncommands that we defined earlier:\n*)\n// By default, go forward by 10 pixels\nlet defaultLength = 10.0\n\n// Convert processed l-system string to turtle commands\nlet convertToTurtle angle (lSystemString: string) =\n  let defaultAngle = 1.0 * angle\n  lSystemString.ToCharArray() |> Array.map (function\n    // Special commands that mean something\n    | '+' -> Turn(defaultAngle)\n    | '-' -> Turn(-defaultAngle)\n    | '!' -> RandomColor\n    | '[' -> Push\n    | ']' -> Pop\n    // Anything else is treated as move forward\n    | _ -> DrawForward(defaultLength) )\n  |> Array.toList\n(**\nParsing L-system specifications\n-------------------------------\n\nNow we are almost done - we just need to parse the L-system specification given by the user and\nthen we need to put everything together. There are a number of things that can go wrong when parsing\nthe specification, so we'll need a function for reporting errors. This uses the HTML library\nthat we used for generating SVG images:\n*)\nlet error msg =\n  h?p [] [\n    h?strong [] [text \"Error: \"]\n    text msg\n  ] |> renderTo (document.getElementById(\"errors\"))\n(**\nWhen parsing an input, we split it into lines. Each line is either an axiom (when it does not\ncontain `->`) or a production rule. When parsing productions, we simply find the part before\n`->` and after `->` and create a function that uses the collected rules to implement mapping\nthat we can use to construct `LSystem` value:\n*)\nlet parse (s:string) =\n  // Clear errors and split lines into axioms and procutions\n  h?div [] [] |> renderTo (document.getElementById(\"errors\"))\n  let prods, ax = s.Trim().Split('\\n') |> Array.partition (fun s -> s.Contains(\"->\"))\n\n  // There shold be exactly one axiom\n  let axiom =\n    if ax.Length <> 1 then error(\"There should be exactly one axiom\"); \"A\"\n    else ax.[0].Trim()\n\n  // Collect production rules\n  let prods =\n    prods |> Array.map (fun s ->\n      let i = s.IndexOf(\"->\")\n      let c = s.Substring(0, i).Trim()\n      let c =\n        if c.Length = 1 then c.ToCharArray().[0]\n        else error(\"Production rule should have one thing on the left\"); 'A'\n      let t = s.Substring(i+2).Trim()\n      c, t)\n\n  // Build an L-system specification\n  { Axiom = axiom\n    Productions = fun c ->\n      match prods |> Array.tryFind (fun (k, _) -> k = c) with\n      | Some(_, r) -> r\n      | _ -> string c }\n(**\nPutting everything together\n---------------------------\n\nThe last step is to implement the user interface. We have a number of elements on the page\nthat we can access using `document.getElementById` - for some, we need to access their value,\nso we cast them to the appropriate HTML element type:\n*)\nlet cont = document.getElementById(\"output\")\nlet input = document.getElementById(\"input\") :?> HTMLTextAreaElement\nlet iters = document.getElementById(\"iterations\") :?> HTMLInputElement\nlet angle = document.getElementById(\"angle\") :?> HTMLInputElement\nlet width = document.getElementById(\"width\") :?> HTMLInputElement\n(**\nAn initial turtle starts in the middle (the position will be re-scaled later, so it does not\nmatter) and has initially red color:\n*)\nlet turtle =\n  { angle = 0.0; x = 0.0; y = 0.0\n    c = { r = 255; g = 0; b = 0 } }\n(**\nNow the most beautiful part of the source code - the `run` function just composes all the steps\nthat we created so far using the `|>` operator. We take the input, parse it, run the L-system using\nthe given number of iterations, turn it into Turtle commands, turn that into line segments and\nrender the line segments:\n*)\nlet run () =\n  parse input.value\n  |> processLsystem (int iters.value)\n  |> convertToTurtle (float angle.value)\n  |> processTurtle turtle\n  |> render (int width.value)\n  |> renderTo cont\n(**\nFinally, we call `run` when any of the configuration parameters change and we also run it when\nthe page loads:\n*)\ninput.addEventListener_keyup(fun _ -> run(); box())\niters.addEventListener_change(fun _ -> run(); box())\nangle.addEventListener_change(fun _ -> run(); box())\nwidth.addEventListener_change(fun _ -> run(); box())\nrun()\n"]}