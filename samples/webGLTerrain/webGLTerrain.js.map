{"version":3,"sources":["../samples/browser/webGLTerrain/webGLTerrain.fsx"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA,kDAsEqB,kBAtErB;AAAA,kDAuEqB,kBAvErB;AAAA,gCAyEY,kBAzEZ;;AAqFQ;AAAO;AAAP;AAES;AAFT;AAII,gBAZQ,aAYR;;AAER,qCACI;AAAA,iCAAa,QAAb,OACQ;AAAI;AACA;AAEJ,yCAAa,WAAb,EAAgC,WAAhC;AAEJ,0BAAY,UAAY,eAAxB;AALK;;AAMT,sBAAW,WAAX;AAAwB;;AAdxB;AAAI;;AAuBJ;AAAU;AACJ,kBAAC,2BAAD;AAEG;AACb;AACA;AAEc;AACd;AACA;AAEY;AAEI;AAbZ;AAAA;AAiBY;;AAEhB,eAAM,KAAN,EAMI;AAAA,wBAAa,KAAO,KAAP,SAAwB,KAAxB,CAAb;AACA;AACA,wBAAa,KAAO,IAAI,SAAX,SAAgC,IAAI,SAApC,CAAb;AACA;AAEY;AALZ,2BAQI,CAAC,KAAO,WAAR,KAA0B,MAAM,eAAhC,CARJ;AAAA,sBASY,KATZ,IAUI,CAAC,KAAO,UAAR,KAAyB,MAAM,eAA/B,CAVJ;AAAA,sBAWY,KAXZ,IAYK,UAAD,IAAkB,MAAM,eAAxB,CAZJ;AAcA,gBAAK,KAAL;AACA,gBAAK,KAAL;AAAU;;AAEd;AAEmB;AACnB,6BAA4B,SAA5B;AACA,8BAA6B,UAA7B;AAEc;AACd;AACA;AAEY;AAEI;AAtDZ;AAyDY;;AAChB,eAAM,SAAN,EAGQ;AAAI,qBAAK,CAAqB,WA5FtB,aA4FM,IAAgB,CAA1B;AAAJ,+BACe,oBADf;AAAA,wBAEQ,OAFR,IAEmB,YAAY,OAAZ,KAFnB;AAAA,wBAGQ,OAHR,IAGmB,YAAY,OAAZ,KAHnB;AAIJ,kBAAK,OAAL;AAJK;;AAMT;AAnEI;AAAO;;AAmFP;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAOY;AACH,sDACS,aAAa,WADtB;AAED;AAEG;AACf;AACA,yBAAqC,UAArC,EAAiD,WAAjD;AACiB;AACjB;AACA;AAEe;AACf;AACA;AAEW;AAEX,4BACI,KAAM,iBAAiB,2BAAvB,YADJ;AAGe,kEAEY,cAFZ,EAEoC,cAFpC;AAGf,6BAAqB,mCACE,YADF,CAArB;AAIe;AAEA;AACP;AAtCJ;AAAA;;AAyCJ,eAAM,KAAN,EACI;AAAA,uBAAU,KAAV,IAAoB,YAApB;AACA,gBAAK,KAAL;AACA,gBAAK,KAAL;AAAU;;AAEE;AACF;AAId;AAMe;AACf;AAEW,6CAAqB,sCAArB;AACX;;AAGI;AAAA,4BAAiB,aAAa,WAA9B;AACA;AACA,6BAAqC,UAArC,EAAiD,WAAjD;AACA;AAHA;AAII,SAJJ;;AAhEA,0CAuEU;AAAA;AAAA,SAvEV;AAAA;AAAU;;AA/LlB,2BA0QqC,MA1QrC;AAAA;AAAA;AAAA;AAAA;;AAuRI;AAAA,wBAAgB,gBAAhB;AACA;AAA8B;;AAG9B;AAAA,qCAA+C;AAAA;AAAO,SAAtD;AAEA;AAAQ;;AAGZ","file":"webGLTerrain.js","sourceRoot":"/Users/alfonsogarciacaronunez/Documents/Github/Fable/temp","sourcesContent":["(**\n - title: WebGL Geometry Terrain\n - tagline: A 3D world right in the browser\n - app-style: height:450px; width:800px; margin:20px auto 50px auto;\n - intro: This demo is a Fable port of the [WebGL Geometry Terrain](http://threejs.org/examples/#webgl_geometry_terrain)\n   three.js demo. It uses the three.js library to randomly generate a 3D terrain which can be navigated in a first-person view.\n   The code was originally written by [John Quigley](https://github.com/jmquigs) for FunScript,\n   you can find [Fable's version on GitHub](https://github.com/fsprojects/Fable/blob/master/samples/browser/webGLTerrain/webGLTerrain.fsx).\n\n   On the technical side, the demo shows some of the more interesting aspects of\n   calling JavaScript libraries from Fable. You'll learn how to define mapping for\n   global objects and other useful functions.\n*)\n(*** hide ***)\n#r \"node_modules/fable-core/Fable.Core.dll\"\n#load \"node_modules/fable-import-three/Fable.Import.Three.fs\"\n(**\nJavaScript helpers and imports\n------------------------------\n\nFable comes with [an F# mapping for three.js](https://github.com/fsprojects/Fable/tree/master/import/three),\nwhich defines all the types and functions for three.js that we'll need in this example.\nIn addition this demo uses custom scripts for ImprovedNoise and FirstPersonControls.\nWe'll write the mappings for those two inline.\n*)\n\nopen System\nopen Fable.Core\nopen Fable.Core.JsInterop\nopen Fable.Import\n\n/// Represents the API exposed by ImprovedNoise script\ntype IPerlin =\n    abstract noise: x:float * y:float * z:float -> float\n\n/// Represents the API exposed by FirstPersonControls script\ntype IFirstPersonControls =\n    abstract movementSpeed: float with get, set\n    abstract lookSpeed: float with get, set\n    abstract handleResize: unit -> unit\n    abstract update: float -> unit\n\n(**\nThe `Global` attribute on ImprovedNoise specifies that the function is globally available.\n\nFirstPersonControls is a bit more complicated because we need to use the `new` keyword.\nFable won't do this automatically so we make sure the proper JS is emitted with `Emit` attribute.\nThe dots after the placeholder `$0...` indicate any additional argument must also be applied in JS.\nThis is very useful when we have a method with `ParamArray` args.\n*)\n\n// Globally imported JS libs (loaded with <script> tag)    \n[<Global>]\nlet ImprovedNoise(): IPerlin = failwith \"JS only\"\n\n[<Emit(\"new THREE.FirstPersonControls($0...)\")>]\nlet FirstPersonControls(camera: Three.Camera,\n                        domElement: Browser.HTMLElement):\n                        IFirstPersonControls = failwith \"JS only\"\n\n(**\nInitial settings and helper functions\n------------------------------------\n\nNote: this sample is intended to be a direct port of the original\nand doesn't attempt to refactor the original to be more \"functional\".\n*)\n\nlet worldWidth = 256\nlet worldDepth = 256\nlet worldHalfWidth = worldWidth / 2\nlet worldHalfDepth = worldDepth / 2\n\nlet clock = Three.Clock()\n\n// We can also use `System.Random`, but the native JS `Math.random`\n// will be a bit more performant here.\nlet inline rand() = JS.Math.random()\n\n(**\nUsing the perlin library (ImprovedNoise script) define the peaks\nof the mountains in our random terrain.\n*)\n\nlet generateHeight width height =\n    let size = width * height\n    let data:float[] = Array.zeroCreate size\n    let perlin = ImprovedNoise()\n    let mutable quality = 1.0\n    let z = rand() * 100.0\n\n    for j in 0..3 do\n        for i in 0..(size-1) do\n            let x = i % width\n            let y = i / width\n            let noise =\n                perlin.noise(float x / quality, float y / quality, z)\n                    * quality * 1.75\n            data.[i] <- data.[i] + (JS.Math.abs ( noise ))\n        quality <- quality * 5.0\n    data\n\n(**\nTo generate the textures for the terrain, we'll be using a canvas element\nto draw the image and later pass it directly to THREE.Texture class.\n*)\n\nlet generateTexture (data:float[]) (width:int) (height:int) = \n    let vector3 = Three.Vector3(0.0, 0.0, 0.0)\n    let sun = (Three.Vector3(1.0, 1.0, 1.0) :> Three.Vector).normalize()\n\n    let canvas = Browser.document.createElement_canvas()\n    canvas.width <- float width\n    canvas.height <- float height\n\n    let context = canvas.getContext_2d()\n    context.fillStyle <- U3.Case1 \"#000\"\n    context.fillRect(0.0, 0.0, float width, float height)\n\n    let image = context.getImageData(\n                    0.0, 0.0, canvas.width, canvas.height)\n    let imageData = image.data\n\n    let mutable i = 0\n    let mutable j = 0\n    let mutable l = int imageData.length\n\n    while i < l do\n        // Note: data elements -2 and -1 are accessed here at the start\n        // of the loop. It's a bug in the original (producing NaN after\n        // normalize()), but JS just keeps on truckin'. There is a similar\n        // issue with z.  The result is that imageData is set to zero (black)\n        // in these cases\n        vector3.x <- data.[ j - 2 ] - data.[ j + 2 ]\n        vector3.y <- 2.0\n        vector3.z <- data.[ j - width * 2 ] - data.[ j + width * 2 ]\n        (vector3 :> Three.Vector).normalize() |> ignore\n\n        let shade = vector3.dot(sun :?> Three.Vector3)\n\n        imageData.[ i ] <-\n            (96.0 + shade * 128.0) * (0.5 + data.[ j ] * 0.007)\n        imageData.[ i + 1 ] <-\n            (32.0 + shade * 96.0) * (0.5 + data.[ j ] * 0.007)\n        imageData.[ i + 2 ] <-\n            (shade * 96.0) * (0.5 + data.[ j ] * 0.007)\n\n        i <- i + 4\n        j <- j + 1\n\n    context.putImageData( image, 0.0, 0.0 );\n\n    let canvasScaled = Browser.document.createElement_canvas()\n    canvasScaled.width <- float(width * 4)\n    canvasScaled.height <- float(height * 4)\n\n    let context = canvasScaled.getContext_2d()\n    context.scale(4.0,4.0)\n    context.drawImage(U3.Case2 canvas, 0.0, 0.0)\n\n    let image = context.getImageData(\n                    0.0, 0.0, canvasScaled.width, canvasScaled.height)\n    let imageData = image.data\n\n    let mutable i = 0\n    let mutable l = int imageData.length\n    while i < l do\n        // I presume double-not is used here for this reason:\n        // http://james.padolsey.com/javascript/double-bitwise-not/\n        let v = ~~~ (~~~ (rand() * 5.0 |> int)) |> float\n        imageData.[ i ] <- imageData.[ i ] + v\n        imageData.[ i + 1 ] <- imageData.[ i + 1 ] + v\n        imageData.[ i + 2 ] <- imageData.[ i + 2 ] + v\n        i <- i + 4\n\n    context.putImageData(image, 0.0, 0.0)\n    canvasScaled\n\n(**\nInitialize elements\n-------------------\n\nHere we initialize the elements necessary to draw the scene:\nthe renderer, the scene itself, a camera and controls to move it.\n\nNote the use of a compiler directive: normally we take the whole window space,\nbut if we are in the tutorial we should leave space for the explanations.\n*)\n\nlet init() =\n    #if TUTORIAL\n    let getWidth() = 800.\n    let getHeight() = 450.\n    #else\n    let getWidth() = Browser.window.innerWidth\n    let getHeight() = Browser.window.innerHeight\n    #endif\n\n    let container = Browser.document.getElementById(\"container\")\n    let camera = Three.PerspectiveCamera(\n                    60.0, getWidth() / getHeight(), 1.0, 20000.0)\n    let scene = Three.Scene()\n    \n    let renderer = Three.WebGLRenderer()\n    renderer.setClearColor(\"#bfd1e5\")\n    (renderer :> Three.Renderer).setSize(getWidth(), getHeight())\n    let domElement = (renderer :> Three.Renderer).domElement\n    container.innerHTML <- \"\"\n    container.appendChild(domElement) |> ignore\n\n    let controls = FirstPersonControls(camera :> Three.Camera, domElement)\n    controls.movementSpeed <- 1000.0\n    controls.lookSpeed <- 0.1\n\n    let data = generateHeight worldWidth worldDepth\n\n    camera.position.y <-\n        data.[worldHalfWidth + worldHalfDepth * worldWidth] * 10. + 500.\n\n    let geometry = Three.PlaneBufferGeometry(\n                        7500.0, 7500.0,\n                        float (worldWidth - 1), float (worldDepth - 1))\n    geometry.applyMatrix(Three.Matrix4()\n            .makeRotationX(-JS.Math.PI / 2.0))\n            |> ignore\n\n    let vertices = geometry.getAttribute(\"position\")\n                    |> unbox<Three.BufferAttribute>\n    let vertices = vertices.array\n    let l = int vertices.length\n    let mutable i = 0\n    let mutable j = 0\n    while i < l do\n        vertices.[j + 1] <- data.[i] * 10.0\n        i <- i + 1\n        j <- j + 3\n\n    let texCanvas = generateTexture data worldWidth worldDepth\n    let texture = Three.Texture(\n                    U3.Case2 texCanvas, Three.UVMapping,\n                    Three.ClampToEdgeWrapping,\n                    Three.ClampToEdgeWrapping)\n    texture.needsUpdate <- true\n\n    // We use createEmpty here to create an empty object used to set\n    // configuration parameters. The type qualifier indicates what fields\n    // we will be able to set on the resulting object. For those fields that\n    // are enum types, the possible values are usually found in three globals.\n    let matProps = createEmpty<Three.MeshBasicMaterialParameters>\n    matProps.map <- Some texture\n\n    let mesh = Three.Mesh(geometry, Three.MeshBasicMaterial(matProps))\n    scene.add mesh\n\n    let onWindowResize(e:Browser.UIEvent):obj =\n        camera.aspect <- getWidth() / getHeight()\n        camera.updateProjectionMatrix()\n        (renderer :> Three.Renderer).setSize(getWidth(), getHeight())\n        controls.handleResize() \n        null\n\n    Browser.window.addEventListener_resize(\n        Func<_,_> onWindowResize, false)\n\n    renderer, scene, camera, controls\n\nlet renderer,scene,camera,controls = init()\n\n\n(**\nStart animation\n---------------\n\nNow the only thing left is to start the animation. Note we use the\n`window.requestAnimationFrame` function here, this will make sure\n`animate` is executed at a proper frame rate.\n*)\n\nlet render() =\n    controls.update(clock.getDelta())\n    renderer.render(scene, camera)\n\nlet rec animate (dt:float) =\n    Browser.window.requestAnimationFrame(Func<_,_> animate)\n    |> ignore\n    render()\n\n// kick it off\nanimate(0.0)\n"]}