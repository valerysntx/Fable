{"version":3,"sources":["../samples/browser/ozmo/ozmo.fsx"],"names":[],"mappings":"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","file":"ozmo.js","sourcesContent":["(**\n - title: Ozmo game\n - tagline: Phil Trelford's classic ported to Fable\n - app-style: height:668px; width:900px; margin:20px auto 20px auto;\n - intro: Phil Trelford's [classic Ozmo game](https://twitter.com/ptrelford/status/475395178208174080), originally hosted\n   [on BitBucket](https://bitbucket.org/ptrelford/ozmo) ported to Fable! Shows how to handle keyboard events and\n   use HTML5 canvas. You can also get it (as a JavaScript app) from [the Windows\n   Store](https://www.microsoft.com/en-gb/store/apps/ozmo/9nblggh4rjng). View the [raw source code on\n   GitHub](https://github.com/fsprojects/Fable/blob/master/samples/browser/ozmo/ozmo.fsx).\n   To play the game, use left and right keys!\n\n\n*)\n(*** hide ***)\n#r \"node_modules/fable-core/Fable.Core.dll\"\nopen Fable.Core\nopen Fable.Import.Browser\n\n[<Emit(\"Math.random()\")>]\nlet rand (): float = failwith \"JS only\"\n\nmodule Keyboard =\n  let mutable keysPressed = Set.empty\n  let code x = if keysPressed.Contains(x) then 1 else 0\n  let arrows () = (code 39 - code 37, code 38 - code 40)\n  let update (e : KeyboardEvent, pressed) =\n    let keyCode = int e.keyCode\n    let op =  if pressed then Set.add else Set.remove\n    keysPressed <- op keyCode keysPressed\n    null\n  let init () =\n    window.addEventListener_keydown(fun e -> update(e, true))\n    window.addEventListener_keyup(fun e -> update(e, false))\n\n/// The width of the canvas\nlet width = 900.\n/// The height of the canvas\nlet height = 668.\n/// Height of the floor - the bottom black part\nlet floorHeight = 100.\n/// Height of the atmosphere - the yellow gradient\nlet atmosHeight = 300.\n\nKeyboard.init()\n\nlet canvas = document.getElementsByTagName_canvas().[0]\nlet ctx = canvas.getContext_2d()\ncanvas.width <- width\ncanvas.height <- height\n\n(**\nThis demo shows a simple game written using Fable and HTML5 canvas. One interesting\naspect of the game is the [asynchronous game loop](#Asynchronous-game-loop), which\nupdates the game state 60 times per second in a loop. This is implemented using F#\nasynchronous workflows, which make it possible to capture the logic as a recursive\nfunction, rather than using mutable state.\n\nThe Ozmo game uses the [Keyboard helpers from the Mario sample](../mario/index.html#Keyboard-helpers),\nso if you want to see those, check out the Mario sample first - it is also simpler,\nso you can check it out for lighter introduction to Fable and F#.\n\n## Drawing the world\n\nThe first few functions in the game deal with rendering. The world consists of two\ngradients (with yellow orange gradient in the sky and gray gradient for the atmosphere)\nand a filled black rectangle. The `drawGrd` function draws a gradient and `drawBg`\nrenders the world. We also need `drawText` for printing text when the game finishes:\n\n*)\n/// Draw gradient between two Y offsets and two colours\nlet drawGrd (ctx:CanvasRenderingContext2D)\n    (canvas:HTMLCanvasElement) (y0,y1) (c0,c1) =\n  let grd = ctx.createLinearGradient(0.,y0,0.,y1)\n  grd.addColorStop(0.,c0)\n  grd.addColorStop(1.,c1)\n  ctx.fillStyle <- U3.Case2 grd\n  ctx.fillRect(0.,y0, canvas.width, y1- y0)\n\n/// Draw background of the Ozmo game\nlet drawBg ctx canvas =\n  drawGrd ctx canvas\n    (0.,atmosHeight) (\"yellow\",\"orange\")\n  drawGrd ctx canvas\n    (atmosHeight, canvas.height-floorHeight)\n    (\"grey\",\"white\")\n  ctx.fillStyle <- U3.Case1 \"black\"\n  ctx.fillRect\n    ( 0.,canvas.height-floorHeight,\n      canvas.width,floorHeight )\n\n/// Draw the specified text (when game finishes)\nlet drawText(text,x,y) =\n  ctx.fillStyle <- U3.Case1 \"white\"\n  ctx.font <- \"bold 40pt\";\n  ctx.fillText(text, x, y)\n(**\n## Representing and drawing blobs\n\nEach of the balls in the game is represented by a `Blob` value that stores\nthe X and Y coordinates, size of the blob (radius), its colour and current speed.\nThe type is used for both falling blobs and for the player's blob:\n*)\ntype Blob =\n  { X:float; Y:float;\n    vx:float; vy:float;\n    Radius:float; color:string }\n(**\nDrawing blob on the canvas is quite easy - the following function does that using\nthe `arc` function of the 2D rendering context of the canvas:\n*)\nlet drawBlob (ctx:CanvasRenderingContext2D)\n    (canvas:HTMLCanvasElement) (blob:Blob) =\n  ctx.beginPath()\n  ctx.arc\n    ( blob.X, canvas.height - (blob.Y + floorHeight + blob.Radius),\n      blob.Radius, 0., 2. * System.Math.PI, false )\n  ctx.fillStyle <- U3.Case1 blob.color\n  ctx.fill()\n  ctx.lineWidth <- 3.\n  ctx.strokeStyle <- U3.Case1 blob.color\n  ctx.stroke()\n(**\n\n## Falling blobs and collisions\n\nThe next step is to define the physics for the game. This consists of several\nfunctions that update the `Blob` objects and are composed to apply all rules of\nphysics in the main game loop.\n*)\n/// Apply key effects on Player's blob - changes X speed\nlet direct (dx,dy) (blob:Blob) =\n  { blob with vx = blob.vx + (float dx)/4.0 }\n\n/// Apply gravity on falling blobs - gets faster every step\nlet gravity (blob:Blob) =\n  if blob.Y > 0. then { blob with vy = blob.vy - 0.1 }\n  else blob\n\n/// Bounde Player's blob off the wall if it hits it\nlet bounce (blob:Blob) =\n  let n = width\n  if blob.X < 0. then\n    { blob with X = -blob.X; vx = -blob.vx }\n  elif (blob.X > n) then\n    { blob with X = n - (blob.X - n); vx = -blob.vx }\n  else blob\n\n/// Move blob by one step - adds X and Y\n/// velocities to the X and Y coordinates\nlet move (blob:Blob) =\n  { blob with\n      X = blob.X + blob.vx\n      Y = max 0.0 (blob.Y + blob.vy) }\n(**\nThe above functions capture the individual aspects of the movement. The\nfollowing put everything together and handle steps of Player's blob and\nalso collision detection.\n*)\n/// Apply step on Player's blob. Composes above functions.\nlet step dir blob =\n  blob |> direct dir |> move |> bounce\n\n/// Check whether two blobs collide\nlet collide (a:Blob) (b:Blob) =\n  let dx = (a.X - b.X)*(a.X - b.X)\n  let dy = (a.Y - b.Y)*(a.Y - b.Y)\n  let dist = sqrt(dx + dy)\n  dist < abs(a.Radius - b.Radius)\n\n/// Remove all falling blobs that hit Player's blob\nlet absorb (blob:Blob) (drops:Blob list) =\n  drops |> List.filter (fun drop ->\n    collide blob drop |> not )\n(**\n## Game logic helpers\n\nNext, we define a couple of helpers for generating and updating the falling blobs.\nWe have black growing blobs and white shrinking blobs. The `newGrow` and `newShrink`\nfunctions are used to generate new blobs:\n*)\nlet grow = \"black\"\nlet shrink = \"white\"\n\nlet newDrop color =\n  { X = rand()*width*0.8 + (width*0.1)\n    Y=600.; Radius=10.; vx=0.; vy = 0.0\n    color=color }\n\nlet newGrow () = newDrop grow\nlet newShrink () = newDrop shrink\n(**\nInside the game loop, we will generate blobs randomly, but we keep a counter of\nticks to make sure that we do not generate new blobs too often. The `updateDrops`\nfunction takes current drops and a countdown and returns a pair with new drops and\na new countdown. It implements simple logic:\n\n - If we generated drop in last 8 steps, do nothing and decrement counter\n - Roll an 8 sided dice and if we get 1, generate new blob\n   (2/3 are shrinkind and 1/3 are growing)\n - Otherwise, do nothing and return previous state\n\n*)\n/// Update drops and countdown in each step\nlet updateDrops drops countdown =\n  if countdown > 0 then\n    drops, countdown - 1\n  elif floor(rand()*8.) = 0. then\n    let drop =\n      if floor(rand()*3.) = 0. then newGrow()\n      else newShrink()\n    drop::drops, 8\n  else drops, countdown\n\n/// Count growing and shrinking drops in the list\nlet countDrops drops =\n  let count color =\n    drops\n    |> List.filter (fun drop -> drop.color = color)\n    |> List.length\n  count grow, count shrink\n\n(**\n## Asynchronous game loop\n\nThe asynchronous game loop is perhaps the most interesting part of the source code.\nFable supports F# asynchronous workflows, which give us a way to write non-blocking loop\nthat includes sleeping in the middle, so you can write long-running processes as a recursive\nloop rather than using timers and callbacks.\n\nThe following diagram illustrates the game loop:\n\n    [lang=text]\n    (start)        +----(tick)---+\n       \\           |             |\n         +------+  |  +--------+ |   +-----------+\n      +->| game |--+->| update |-+-->| completed |<-+\n      |  +------+     +--------+     +-----------+  |\n      |                                             |\n      +-----------(after 10 seconds)----------------+\n\nThere are three states in which the game can be:\n\n - After starting, the `game` state initializes the Player's blob and starts the game\n - The `update` loop is active when the game is running. It calls itself recursively\n   until the game ends.\n - After finishing, the `completed` state displays a message and sleeps for 10 seconds\n   before starting a new game.\n\nUsing asynchronous workflows, the state machine can be represented using 3 mutually\nrecursive functions, each representing one of the states. The `game` and `completed`\nstates are simple:\n*)\n/// Starts a new game\nlet rec game () = async {\n  let blob =\n    { X = 300.; Y=0.; Radius=50.;\n      vx=0.; vy=0.; color=\"black\" }\n  return! update blob [newGrow ()] 0 }\n\n/// Displays message and sleeps for 10 sec\nand completed () = async {\n  drawText (\"COMPLETED\",320.,300.)\n  do! Async.Sleep 10000\n  return! game () }\n(**\nNote that we are using `let rec .. and`, which lets us write multiple recursive functions\nthat can call each other. The `completed` function calls `game` after 10 seconds using\n`return!` (representing an asynchronous tail-call) and the `game` function calls `update`\nwith the initial state. The `update` loop looks as follows:\n*)\n/// Keeps current state for Player's blob, falling\n/// drops and the countdown since last drop was generated\nand update blob drops countdown = async {\n  // Update the drops & countdown\n  let drops, countdown = updateDrops drops countdown\n\n  // Count drops, apply physics and count them again\n  let beforeGrow, beforeShrink = countDrops drops\n  let drops =\n    drops\n    |> List.map (gravity >> move)\n    |> absorb blob\n  let afterGrow, afterShrink = countDrops drops\n  let drops = drops |> List.filter (fun blob -> blob.Y > 0.)\n\n  // Calculate new player's size based on absorbed drops\n  let radius = blob.Radius + float (beforeGrow - afterGrow) *4.\n  let radius = radius - float (beforeShrink - afterShrink) * 4.\n  let radius = max 5.0 radius\n\n  // Update radius and apply keyboard events\n  let blob = { blob with Radius = radius }\n  let blob = blob |> step (Keyboard.arrows())\n\n  // Render the new game state\n  drawBg ctx canvas\n  for drop in drops do drawBlob ctx canvas drop\n  drawBlob ctx canvas blob\n\n  // If the game completed, switch state\n  // otherwise sleep and update recursively!\n  if blob.Radius > 150. then\n    return! completed()\n  else\n    do! Async.Sleep(int (1000. / 60.))\n    return! update blob drops countdown }\n(**\nThe last thing that we need to do is to start the game in the initial `game`\nstate using `Async.StartImmediate`:\n*)\ngame () |> Async.StartImmediate\n"]}