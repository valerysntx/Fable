{"version":3,"sources":["../samples/browser/ozmo/ozmo.fsx"],"names":[],"mappings":"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","file":"ozmo.js","sourceRoot":"/Users/alfonsogarciacaronunez/Documents/Github/Fable/temp","sourcesContent":["(**\n - title: Ozmo game\n - tagline: Phil Trelford's classic ported to Fable\n - app-style: height:668px; width:900px; margin:20px auto 20px auto;\n - intro: Phil Trelford's [classic Ozmo game](https://twitter.com/ptrelford/status/475395178208174080), originally hosted\n   [on BitBucket](https://bitbucket.org/ptrelford/ozmo) ported to Fable! Shows how to handle keyboard events and\n   use HTML5 canvas. You can also get it (as a JavaScript app) from [the Windows\n   Store](https://www.microsoft.com/en-gb/store/apps/ozmo/9nblggh4rjng). View the [raw source code on\n   GitHub](https://github.com/fsprojects/Fable/blob/master/samples/browser/ozmo/ozmo.fsx).\n   To play the game, use left and right keys!\n\n\n*)\n(*** hide ***)\n#r \"node_modules/fable-core/Fable.Core.dll\"\nopen Fable.Core\nopen Fable.Import.Browser\n\n[<Emit(\"Math.random()\")>]\nlet rand (): float = failwith \"JS only\"\n\nmodule Keyboard =\n  let mutable keysPressed = Set.empty\n  let code x = if keysPressed.Contains(x) then 1 else 0\n  let arrows () = (code 39 - code 37, code 38 - code 40)\n  let update (e : KeyboardEvent, pressed) =\n    let keyCode = int e.keyCode\n    let op =  if pressed then Set.add else Set.remove\n    keysPressed <- op keyCode keysPressed\n    null\n  let init () =\n    window.addEventListener_keydown(fun e -> update(e, true))\n    window.addEventListener_keyup(fun e -> update(e, false))\n\n/// The width of the canvas\nlet width = 900.\n/// The height of the canvas\nlet height = 668.\n/// Height of the floor - the bottom black part\nlet floorHeight = 100.\n/// Height of the atmosphere - the yellow gradient\nlet atmosHeight = 300.\n\nKeyboard.init()\n\nlet canvas = document.getElementsByTagName_canvas().[0]\nlet ctx = canvas.getContext_2d()\ncanvas.width <- width\ncanvas.height <- height\n\n(**\nThis demo shows a simple game written using Fable and HTML5 canvas. One interesting\naspect of the game is the [asynchronous game loop](#Asynchronous-game-loop), which\nupdates the game state 60 times per second in a loop. This is implemented using F#\nasynchronous workflows, which make it possible to capture the logic as a recursive\nfunction, rather than using mutable state.\n\nThe Ozmo game uses the [Keyboard helpers from the Mario sample](../mario/index.html#Keyboard-helpers),\nso if you want to see those, check out the Mario sample first - it is also simpler,\nso you can check it out for lighter introduction to Fable and F#.\n\n## Drawing the world\n\nThe first few functions in the game deal with rendering. The world consists of two\ngradients (with yellow orange gradient in the sky and gray gradient for the atmosphere)\nand a filled black rectangle. The `drawGrd` function draws a gradient and `drawBg`\nrenders the world. We also need `drawText` for printing text when the game finishes:\n\n*)\n/// Draw gradient between two Y offsets and two colours\nlet drawGrd (ctx:CanvasRenderingContext2D)\n    (canvas:HTMLCanvasElement) (y0,y1) (c0,c1) =\n  let grd = ctx.createLinearGradient(0.,y0,0.,y1)\n  grd.addColorStop(0.,c0)\n  grd.addColorStop(1.,c1)\n  ctx.fillStyle <- U3.Case2 grd\n  ctx.fillRect(0.,y0, canvas.width, y1- y0)\n\n/// Draw background of the Ozmo game\nlet drawBg ctx canvas =\n  drawGrd ctx canvas\n    (0.,atmosHeight) (\"yellow\",\"orange\")\n  drawGrd ctx canvas\n    (atmosHeight, canvas.height-floorHeight)\n    (\"grey\",\"white\")\n  ctx.fillStyle <- U3.Case1 \"black\"\n  ctx.fillRect\n    ( 0.,canvas.height-floorHeight,\n      canvas.width,floorHeight )\n\n/// Draw the specified text (when game finishes)\nlet drawText(text,x,y) =\n  ctx.fillStyle <- U3.Case1 \"white\"\n  ctx.font <- \"bold 40pt\";\n  ctx.fillText(text, x, y)\n(**\n## Representing and drawing blobs\n\nEach of the balls in the game is represented by a `Blob` value that stores\nthe X and Y coordinates, size of the blob (radius), its colour and current speed.\nThe type is used for both falling blobs and for the player's blob:\n*)\ntype Blob =\n  { X:float; Y:float;\n    vx:float; vy:float;\n    Radius:float; color:string }\n(**\nDrawing blob on the canvas is quite easy - the following function does that using\nthe `arc` function of the 2D rendering context of the canvas:\n*)\nlet drawBlob (ctx:CanvasRenderingContext2D)\n    (canvas:HTMLCanvasElement) (blob:Blob) =\n  ctx.beginPath()\n  ctx.arc\n    ( blob.X, canvas.height - (blob.Y + floorHeight + blob.Radius),\n      blob.Radius, 0., 2. * System.Math.PI, false )\n  ctx.fillStyle <- U3.Case1 blob.color\n  ctx.fill()\n  ctx.lineWidth <- 3.\n  ctx.strokeStyle <- U3.Case1 blob.color\n  ctx.stroke()\n(**\n\n## Falling blobs and collisions\n\nThe next step is to define the physics for the game. This consists of several\nfunctions that update the `Blob` objects and are composed to apply all rules of\nphysics in the main game loop.\n*)\n/// Apply key effects on Player's blob - changes X speed\nlet direct (dx,dy) (blob:Blob) =\n  { blob with vx = blob.vx + (float dx)/4.0 }\n\n/// Apply gravity on falling blobs - gets faster every step\nlet gravity (blob:Blob) =\n  if blob.Y > 0. then { blob with vy = blob.vy - 0.1 }\n  else blob\n\n/// Bounde Player's blob off the wall if it hits it\nlet bounce (blob:Blob) =\n  let n = width\n  if blob.X < 0. then\n    { blob with X = -blob.X; vx = -blob.vx }\n  elif (blob.X > n) then\n    { blob with X = n - (blob.X - n); vx = -blob.vx }\n  else blob\n\n/// Move blob by one step - adds X and Y\n/// velocities to the X and Y coordinates\nlet move (blob:Blob) =\n  { blob with\n      X = blob.X + blob.vx\n      Y = max 0.0 (blob.Y + blob.vy) }\n(**\nThe above functions capture the individual aspects of the movement. The\nfollowing put everything together and handle steps of Player's blob and\nalso collision detection.\n*)\n/// Apply step on Player's blob. Composes above functions.\nlet step dir blob =\n  blob |> direct dir |> move |> bounce\n\n/// Check whether two blobs collide\nlet collide (a:Blob) (b:Blob) =\n  let dx = (a.X - b.X)*(a.X - b.X)\n  let dy = (a.Y - b.Y)*(a.Y - b.Y)\n  let dist = sqrt(dx + dy)\n  dist < abs(a.Radius - b.Radius)\n\n/// Remove all falling blobs that hit Player's blob\nlet absorb (blob:Blob) (drops:Blob list) =\n  drops |> List.filter (fun drop ->\n    collide blob drop |> not )\n(**\n## Game logic helpers\n\nNext, we define a couple of helpers for generating and updating the falling blobs.\nWe have black growing blobs and white shrinking blobs. The `newGrow` and `newShrink`\nfunctions are used to generate new blobs:\n*)\nlet grow = \"black\"\nlet shrink = \"white\"\n\nlet newDrop color =\n  { X = rand()*width*0.8 + (width*0.1)\n    Y=600.; Radius=10.; vx=0.; vy = 0.0\n    color=color }\n\nlet newGrow () = newDrop grow\nlet newShrink () = newDrop shrink\n(**\nInside the game loop, we will generate blobs randomly, but we keep a counter of\nticks to make sure that we do not generate new blobs too often. The `updateDrops`\nfunction takes current drops and a countdown and returns a pair with new drops and\na new countdown. It implements simple logic:\n\n - If we generated drop in last 8 steps, do nothing and decrement counter\n - Roll an 8 sided dice and if we get 1, generate new blob\n   (2/3 are shrinkind and 1/3 are growing)\n - Otherwise, do nothing and return previous state\n\n*)\n/// Update drops and countdown in each step\nlet updateDrops drops countdown =\n  if countdown > 0 then\n    drops, countdown - 1\n  elif floor(rand()*8.) = 0. then\n    let drop =\n      if floor(rand()*3.) = 0. then newGrow()\n      else newShrink()\n    drop::drops, 8\n  else drops, countdown\n\n/// Count growing and shrinking drops in the list\nlet countDrops drops =\n  let count color =\n    drops\n    |> List.filter (fun drop -> drop.color = color)\n    |> List.length\n  count grow, count shrink\n\n(**\n## Asynchronous game loop\n\nThe asynchronous game loop is perhaps the most interesting part of the source code.\nFable supports F# asynchronous workflows, which give us a way to write non-blocking loop\nthat includes sleeping in the middle, so you can write long-running processes as a recursive\nloop rather than using timers and callbacks.\n\nThe following diagram illustrates the game loop:\n\n    [lang=text]\n    (start)        +----(tick)---+\n       \\           |             |\n         +------+  |  +--------+ |   +-----------+\n      +->| game |--+->| update |-+-->| completed |<-+\n      |  +------+     +--------+     +-----------+  |\n      |                                             |\n      +-----------(after 10 seconds)----------------+\n\nThere are three states in which the game can be:\n\n - After starting, the `game` state initializes the Player's blob and starts the game\n - The `update` loop is active when the game is running. It calls itself recursively\n   until the game ends.\n - After finishing, the `completed` state displays a message and sleeps for 10 seconds\n   before starting a new game.\n\nUsing asynchronous workflows, the state machine can be represented using 3 mutually\nrecursive functions, each representing one of the states. The `game` and `completed`\nstates are simple:\n*)\n/// Starts a new game\nlet rec game () = async {\n  let blob =\n    { X = 300.; Y=0.; Radius=50.;\n      vx=0.; vy=0.; color=\"black\" }\n  return! update blob [newGrow ()] 0 }\n\n/// Displays message and sleeps for 10 sec\nand completed () = async {\n  drawText (\"COMPLETED\",320.,300.)\n  do! Async.Sleep 10000\n  return! game () }\n(**\nNote that we are using `let rec .. and`, which lets us write multiple recursive functions\nthat can call each other. The `completed` function calls `game` after 10 seconds using\n`return!` (representing an asynchronous tail-call) and the `game` function calls `update`\nwith the initial state. The `update` loop looks as follows:\n*)\n/// Keeps current state for Player's blob, falling\n/// drops and the countdown since last drop was generated\nand update blob drops countdown = async {\n  // Update the drops & countdown\n  let drops, countdown = updateDrops drops countdown\n\n  // Count drops, apply physics and count them again\n  let beforeGrow, beforeShrink = countDrops drops\n  let drops =\n    drops\n    |> List.map (gravity >> move)\n    |> absorb blob\n  let afterGrow, afterShrink = countDrops drops\n  let drops = drops |> List.filter (fun blob -> blob.Y > 0.)\n\n  // Calculate new player's size based on absorbed drops\n  let radius = blob.Radius + float (beforeGrow - afterGrow) *4.\n  let radius = radius - float (beforeShrink - afterShrink) * 4.\n  let radius = max 5.0 radius\n\n  // Update radius and apply keyboard events\n  let blob = { blob with Radius = radius }\n  let blob = blob |> step (Keyboard.arrows())\n\n  // Render the new game state\n  drawBg ctx canvas\n  for drop in drops do drawBlob ctx canvas drop\n  drawBlob ctx canvas blob\n\n  // If the game completed, switch state\n  // otherwise sleep and update recursively!\n  if blob.Radius > 150. then\n    return! completed()\n  else\n    do! Async.Sleep(int (1000. / 60.))\n    return! update blob drops countdown }\n(**\nThe last thing that we need to do is to start the game in the initial `game`\nstate using `Async.StartImmediate`:\n*)\ngame () |> Async.StartImmediate\n"]}